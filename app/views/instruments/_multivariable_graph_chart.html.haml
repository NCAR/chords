(??)
(??)- # Define a few global variables

:javascript
  //////////////////////////////////////////////////
  ////////// Initialization of Variables ///////////
  //////////////////////////////////////////////////

(??)  var live_chart; 
(??)  var last_time = 0;
(??)  var last_times = [];
(??)  var pause = false;

  // intialize varaible to hold Highchart
  var live_chart;

  // initialize variable that holds last time of last recorded measurement for any variable

  // initialze array that holds time of last recorded measurement for each variable
  var live_last_times = [];

  // initialize variable that determines how often to fetch new data
  var live_refresh_msecs;

  // array that holds all variables of current instrument
  var variables = #{@instrument.vars.to_json.html_safe};

  // Craft a title for the charts
  var live_title = "#{@instrument.name}" + "- Live Data";
(??)
(??)- # Craft a title for the chart
(??)- title = "\"#{@instrument.name} - Live Data\""
(??)- title  = title.as_json.html_safe

  // populate y_axis_js and live_series array
  var visible_by_default = true;
  var variable_index = 0;
  variables.forEach (function(v) {

- @instrument.vars.each do |v|
  - y_axis_js_part = ""
  - y_axis_js_part += "{  "
  - y_axis_js_part += "  labels: {\n"
  - y_axis_js_part += "      format: '{value.html_safe}#{v.unit.try(:abbreviation).html_safe}',\n"
  - y_axis_js_part += "       style: {color: Highcharts.getOptions().colors[#{variable_index}]},\n"
  - y_axis_js_part += "  },\n"

  - y_axis_js_part += "  title: { \n "
  - y_axis_js_part += "   text: '#{v.name.html_safe} (#{v.unit.try(:abbreviation).html_safe})',\n"
  - y_axis_js_part += "       style: {color: Highcharts.getOptions().colors[#{variable_index}]},\n"

    y_axis_js_part += '  "opposite": false,\n';
    y_axis_js_part += '  "showEmpty": false,\n';
    y_axis_js_part += '  "plotLines": [{\n';
    y_axis_js_part += '   "width": 0.5\n';
    y_axis_js_part += '  }]\n';

    y_axis_js_part += '}';
(??)  - y_axis_js_part = ""
(??)  - y_axis_js_part += "{  "
(??)  - #y_axis_js_part += "  #{max_y_axis_json}\n"
(??)  - #y_axis_js_part += "  #{min_y_axis_json}\n"
(??)  - y_axis_js_part += "  labels: {\n"
(??)  - y_axis_js_part += "      format: '{value.html_safe}#{v.unit.try(:abbreviation).html_safe}',\n"
(??)  - y_axis_js_part += "       style: {color: Highcharts.getOptions().colors[#{variable_index}]},\n"
(??)  - y_axis_js_part += "  },\n"

(??)  - y_axis_js_part += "  title: { \n "
(??)  - y_axis_js_part += "   text: '#{v.name.html_safe} (#{v.units.try(:abbreviation).html_safe})',\n"
(??)  - y_axis_js_part += "       style: {color: Highcharts.getOptions().colors[#{variable_index}]},\n"
(??)  
(??)  - y_axis_js_part += "  },\n"
(??)  
(??)  - y_axis_js_part += "  opposite: false  ,\n"
(??)  - y_axis_js_part += "  plotLines: [{\n"
(??)  - y_axis_js_part += "   width: .5,\n"
(??)  - y_axis_js_part += "  }]\n"

(??)  - y_axis_js_part += "}"
(??)  - y_axis_js_parts.push(y_axis_js_part)
(??)  
(??)  :javascript 
(??)    var temp_hash = {name:"#{v.name.html_safe}", visible: #{visible_by_default}, data: [], yAxis: #{variable_index}, lineWidth: 1.3};

    live_last_times.push(0);

    variable_index += 1;
    visible_by_default = false;
  });

(??):javascript

(??)  function requestData() 
(??)  {  
(??)    // If the manual datetime input fields are meing modified (in focus) then don't don't redraw the chart
(??)    if ($('input.highcharts-range-selector:eq(0)').is(":focus") || $('input.highcharts-range-selector:eq(1)').is(":focus"))  {
(??)      pause = true;
(??)    } else {
(??)      pause = false;
    }
(??)    
(??)    // Retrieve the latest points to plot and plot them
(??)    $.getJSON(
(??)    '/instruments/#{@instrument.id}/live?after='+last_time,
(??)    function(live_data) 
(??)      {
(??)
(??)
    // loop through all variables
    for (i = 0; i < multivariable_names.length; i++) {
      // get data corresponding to current variable
      var points = multivariable_points[multivariable_names[i]];
      // loop through points
      for (p = 0; p < points.length; p++) {
        live_chart.series[i].addPoint(points[p], false);
      }

      // update last times array for current variable
      live_last_times[i] = points[points.length - 1][0];
    }
    live_chart.redraw();
  }

  // function that adds new data points to current data in chart for specific variable
  function addNewVarData(data, currVar) {
    // parse through data
    var display_points = data["display_points"];
    var points = data["points"];

(??)            if (variables[series_index].minimum_plot_value) {
(??)              if (minimum_plot_value == null) {
(??)                minimum_plot_value = variables[series_index].minimum_plot_value;
(??)              } else if (variables[series_index].minimum_plot_value < minimum_plot_value) {
(??)                minimum_plot_value = variables[series_index].minimum_plot_value;
(??)              }              
(??)            }

(??)            if (variables[series_index].maximum_plot_value) {
(??)              if (maximum_plot_value == null) {
(??)                maximum_plot_value = variables[series_index].maximum_plot_value;
(??)              } else if (variables[series_index].maximum_plot_value > maximum_plot_value) {
(??)                maximum_plot_value = variables[series_index].maximum_plot_value;
(??)              }              
(??)            }
(??)          }
(??)        }

(??)//        var yAxis = live_chart.yAxis[0];
(??)
(??)//        yAxis.options.startOnTick = true;
(??)//        yAxis.options.endOnTick = true;
(??)        
(??)        var display_points = live_data["display_points"];
(??)        var multivariable_points = live_data["multivariable_points"];
(??)        var multivariable_names = live_data["multivariable_names"];

(??)        var refresh_msecs  = live_data["refresh_msecs"];
(??)        
(??)        for (i = 0; i < multivariable_names.length; i++) {
(??)          // set the min/max for the visible series
(??)          if (series[i].visible) {
(??)            live_chart.yAxis[i].setExtremes(minimum_plot_value, maximum_plot_value, false);
(??)            live_chart.yAxis[i].startOnTick = true;
(??)            live_chart.yAxis[i].endOnTick = true;
(??)          } else {
(??)            live_chart.yAxis[i].setExtremes(null, null, false);
(??)          }

(??)          var points = multivariable_points[multivariable_names[i]];
(??)          
(??)          // Trim the graph if the display width is decreased
(??)//          while (live_chart.series[i].data.length > display_points) {
(??)//            live_chart.series[i].removePoint(0, false);
(??)//          }

(??)          // add the new points
(??)          var point_index;
(??)          
(??)          for (point_index = 0; point_index < points.length; point_index++) {
(??)            if (points[point_index][0] > last_times[i]) {
(??)              var shift = live_chart.series[0].data.length >= display_points;
(??)              live_chart.series[i].addPoint(points[point_index], false, shift);
(??)              last_time = points[point_index][0];
(??)              last_times[i] = points[point_index][0];              
(??)            }
(??)          }

    // request downsampled data and plot
    requestAllLiveData(0, 0, true);
    live_chart.xAxis[0].setExtremes(min, max);
    live_chart.redraw();
  }

(??)        // Don't redraw the chart if live updating is paused
(??)        if (pause == false) {
(??)          live_chart.redraw();        
(??)        }

(??)        // retrieve new data points after a pause
(??)        setTimeout(requestData, refresh_msecs);
(??)      }
(??)    );
  }

(??)
  $(document).ready(function () {
    // adjust the global timezone offset
    Highcharts.setOptions({
      global: {
        timezoneOffset: #{@tz_offset_mins}
      }
    });

(??)    live_chart = new Highcharts.stockChart(
(??)    {
      chart: {
        renderTo: 'instrument_live_chart',
        type: 'line',
        zoomType: 'x',
        events: {
          selection: function(event) {
            zoomSelection(event.xAxis[0].min, event.xAxis[0].max);
          }
        },
        animation: Highcharts.svg,
        marginRight: 10
      },
      rangeSelector: {
        buttons: [],
        inputBoxWidth: 180,
        enabled: true,
        inputEnabled: false,
        inputDateFormat: '%b %e, %Y %H:%M:%S',
        inputEditDateFormat: '%Y-%m-%d %H:%M:%S',
        inputDateParser: function (value) {
          [date, time] = value.split(/[\s]/);
          [year, month, day] = date.split(/[\-]/);
          [hours, minutes, seconds] = time.split(/[\:]/);

          ms =  Date.UTC(
                parseInt(year, 10),
                parseInt(month-1, 10),
                parseInt(day, 10),
                parseInt(hours, 10),
                parseInt(minutes, 10),
                parseInt(seconds, 10)
            );

(??)            // Compensate for the timezone offset
(??)            // This is NOT taken in to account by highcharts and is likely a bug in their code
(??)            tz_offset_ms = #{@tz_offset_mins} * 60 * 1000;
(??)            ms = ms + tz_offset_ms;

(??)            return(ms);
(??)          },
(??)          allButtonsEnabled: false
      },
(??)      credits: { enabled: false, }, 
(??)      title: { text: #{title} },
      xAxis: {
        title: {
          text: '#{@tz_name.html_safe}'
        },
        type: 'datetime',
        tickPixelInterval: 150
      },
      yAxis: y_axis_js,
      tooltip: {
        split: true,
      },
      legend: { enabled: true },
      exporting: { enabled: false },
      series: live_series,
    });

    // make initial data request
    requestAllLiveData(0, 0, true);

    // refresh  data source for each variable
    // setInterval(function() {
      // for (i = 0; i < variables.length; i++) {
        // requestVarLiveData(live_last_times[i], 0, variables[i].shortname);
      // }
    // }, live_refresh_msecs);

    // reset zoom button
    $('#resetZoom').click(function() {
      resetZoom();
    });

    // adjust range button
    $('#adjustRange').click(function() {
      rangeSelection();
    });

    var max = #{@instrument.point_time_in_ms("last").to_time.to_i}
    var offset = parseInt(#{eval("#{@instrument.plot_offset_value}.#{@instrument.plot_offset_units}")});
    var min = max - offset;
    document.getElementById('start').defaultValue = new Date(min * 1000).toISOString().slice(0, -1);
    document.getElementById('end').defaultValue = new Date(max * 1000).toISOString().slice(0, -1);
  });
